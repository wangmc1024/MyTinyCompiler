#!/usr/bin/env python3
import re
import os
import sys

def parse_s_expression(s_expr_string: str):
    """
    将 S-表达式字符串解析为嵌套的 Python 列表。
    例如："(A B (C D))" -> ['A', 'B', ['C', 'D']]
    """
    
    # 1. 规范化：去除多余的空白和换行符，方便正则表达式处理
    s_expr_string = " ".join(s_expr_string.split())

    # 2. 标记化：将字符串分割成 '(', ')', 或 '原子'
    if not s_expr_string:
        return None
    tokens = re.findall(r'\(|\)|[^\s()]+', s_expr_string)
    if not tokens:
        return None

    def build_ast(token_list):
        if not token_list:
            raise ValueError("解析错误：意外的文件结尾")
        
        token = token_list.pop(0)

        if token == '(':
            node_list = []
            # 持续构建列表，直到遇到 ')'
            while token_list and token_list[0] != ')':
                node_list.append(build_ast(token_list))
            
            if not token_list:
                raise ValueError("解析错误：缺少 ')'")
            
            # 消耗 ')'
            token_list.pop(0)
            return node_list
        elif token == ')':
            raise ValueError("解析错误：意外的 ')'")
        else:
            # 这是一个原子/叶子节点 (例如 'S1')
            return token
    
    # 检查是否还有多余的标记（例如：(A B) (C D)）
    result = build_ast(tokens)
    if tokens:
        raise ValueError(f"解析错误：发现多余的标记：{tokens}")
    
    return result

class MermaidConverter:
    """
    将解析后的嵌套列表树转换为 Mermaid 流程图。
    """
    def __init__(self):
        self.node_counter = 0
        self.node_definitions = []  # 存储 "n1[label]"
        self.links = []             # 存储 "n1 --> n2"

    def get_unique_id(self):
        """生成一个唯一的节点ID，例如 n1, n2"""
        self.node_counter += 1
        return f"n{self.node_counter}"

    def convert_to_mermaid(self, parsed_tree):
        """
        转换的公共入口点。
        """
        self.node_counter = 0
        self.node_definitions = []
        self.links = []
        
        if not parsed_tree:
             return "graph TD\n    n1[\"(空树)\"]"
        
        self._traverse(parsed_tree, None)
        
        mermaid_header = "graph TD" # TD = Top-Down
        definitions_str = "\n".join(f"    {d}" for d in self.node_definitions)
        links_str = "\n".join(f"    {link}" for link in self.links)
        
        return f"{mermaid_header}\n{definitions_str}\n{links_str}"

    def _traverse(self, node, parent_id):
        """
        递归遍历树并构建 Mermaid 字符串组件。
        """
        
        if not isinstance(node, list):
            # 基本情况：这是一个原子/叶子节点 (例如 'S1')
            my_id = self.get_unique_id()
            # 清理节点标签中的特殊字符
            cleaned_label = str(node).replace('"', '"').replace('\\', '\\\\')
            self.node_definitions.append(f"{my_id}[\"{cleaned_label}\"]") # "n2[S1]"
            if parent_id:
                self.links.append(f"{parent_id} --> {my_id}")
            return

        if not node:
            # 处理空列表 '()' 的情况
            my_id = self.get_unique_id()
            self.node_definitions.append(f"{my_id}[\"()\"]") # "n3[()]"
            if parent_id:
                self.links.append(f"{parent_id} --> {my_id}")
            return

        # 递归情况：这是一个子树 (一个列表)
        # 列表的第一个元素是这个子树的根
        root_label = node[0] if node else ""
        my_id = self.get_unique_id()
        
        # 确保根标签是字符串，以防出现 '( (A) B )' 这样的情况
        if isinstance(root_label, list):
             # 这是一个没有标签的列表，我们将其标识为"匿名节点"或"结构节点"
             root_label_str = "匿名节点" # 使用有意义的标签替代空格
             self.node_definitions.append(f"{my_id}([\"{root_label_str}\"])") # "n1([匿名节点])"
             
             # 遍历所有子节点
             for child in node:
                self._traverse(child, my_id)
        else:
            # 这是一个常规的带标签的列表
            # 清理节点标签中的特殊字符
            cleaned_label = str(root_label).replace('"', '"').replace('\\', '\\\\')
            self.node_definitions.append(f"{my_id}[\"{cleaned_label}\"]") # "n1[linkSeqList]"

            # 如果它有父节点，则连接它们
            if parent_id:
                self.links.append(f"{parent_id} --> {my_id}")
            
            # 递归遍历所有子节点 (列表的其余部分)
            for child in node[1:]:
                self._traverse(child, my_id) # 自己的 ID 现在是子节点的 parent_id

def read_output_ast_file(file_path):
    """
    读取outputAST.txt文件，尝试不同的编码方式来处理可能的编码问题
    """
    encodings = ['utf-8', 'gbk', 'gb2312', 'latin1']
    
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                content = f.read()
                # 检查是否包含有效的括号结构
                if '(' in content and ')' in content:
                    print(f"成功使用 {encoding} 编码读取文件")
                    return content
        except UnicodeDecodeError:
            print(f"使用 {encoding} 编码读取失败，尝试其他编码...")
            continue
        except Exception as e:
            print(f"读取文件时发生错误: {e}")
            continue
    
    # 如果所有编码都失败，使用latin1编码并警告用户
    print("警告：无法确定正确的文件编码，使用默认编码读取")
    with open(file_path, 'r', encoding='latin1', errors='ignore') as f:
        return f.read()

def generate_html_content(mermaid_code, node_count, link_count, input_source):
    """
    生成包含Mermaid图表的HTML内容
    """
    # 转义Mermaid代码中的特殊字符
    escaped_mermaid_code = mermaid_code.replace('\\', '\\\\').replace('`', '\\`')
    
    html_template = f"""<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AST树结构可视化</title>
    <script type="module">
        import mermaid from 'https://unpkg.com/mermaid@11.4.1/dist/mermaid.min.js';
        mermaid.initialize({{ 
            startOnLoad: true,
            flowchart: {{ 
                useMaxWidth: true,
                maxEdges: 10000
            }}
        }});
    </script>
    <style>
        body {{
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }}
        .container {{
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }}
        h1 {{
            color: #333;
            text-align: center;
        }}
        .info {{
            background-color: #e9f7ef;
            border-left: 4px solid #2ecc71;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }}
        .mermaid-container {{
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 20px;
            margin: 20px 0;
            overflow: auto;
        }}
        .footer {{
            text-align: center;
            margin-top: 20px;
            color: #666;
            font-size: 0.9em;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>AST树结构可视化</h1>
        
        <div class="info">
            <p><strong>输入来源:</strong> {input_source}</p>
            <p><strong>节点总数:</strong> {node_count}</p>
            <p><strong>连接总数:</strong> {link_count}</p>
        </div>
        
        <div class="mermaid-container">
            <pre class="mermaid">
{mermaid_code}
            </pre>
        </div>
        
        <div class="footer">
            <p>使用 Mermaid.js 生成的 AST 树结构图</p>
        </div>
    </div>
</body>
</html>"""
    return html_template

def main():
    """
    主执行函数，硬编码配置
    """
    # 硬编码配置
    input_file = "outputAST.txt"
    output_file = "ast_tree.html"
    
    # 读取 S-表达式
    try:
        input_s_expr = read_output_ast_file(input_file)
        input_source = f"文件 ({input_file})"
    except FileNotFoundError:
        print(f"错误: 文件未找到 {input_file}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"错误: 读取文件时发生异常 {e}", file=sys.stderr)
        sys.exit(1)

    if not input_s_expr.strip():
        print(f"错误: 从 {input_source} 读取的输入为空。", file=sys.stderr)
        sys.exit(1)
        
    print(f"正在从 {input_source} 解析输入...")
    
    try:
        # 解析
        parsed_tree = parse_s_expression(input_s_expr)
        
        if parsed_tree is None:
             print("错误: 输入为空或无法解析。", file=sys.stderr)
             sys.exit(1)

        print(f"解析后的结构长度: {len(str(parsed_tree))}")

        # 转换
        converter = MermaidConverter()
        mermaid_code = converter.convert_to_mermaid(parsed_tree)
        
        print(f"\n生成的节点数量: {converter.node_counter}")
        print(f"生成的连接数量: {len(converter.links)}")
        
        # 检查边数是否超过限制
        if len(converter.links) > 500:
            print(f"警告: 图表包含 {len(converter.links)} 条边，超过了默认的500条边限制")
            print("已在配置中增加边数限制以支持显示大型图表")

        # 生成HTML内容
        html_content = generate_html_content(
            mermaid_code, 
            converter.node_counter, 
            len(converter.links),
            input_source
        )
        
        # 保存HTML文件
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(html_content)
        print(f"\n成功！已将 AST 树结构图保存到: {os.path.abspath(output_file)}")
        print("请在浏览器中打开该文件以查看可视化图表。")

    except ValueError as e:
        print(f"\n!!! 处理 S-表达式 时发生错误 !!!", file=sys.stderr)
        print(f"错误信息: {e}", file=sys.stderr)
        print("请检查您的输入是否包含匹配的括号和正确的格式。", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"\n发生意外错误: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()